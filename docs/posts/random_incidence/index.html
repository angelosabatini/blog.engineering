<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Angelo Maria Sabatini">
<meta name="dcterms.date" content="2024-04-22">
<meta name="description" content="In this post, I briefly discuss the random incidence phenomenon, using the classical example of a person arriving at a bus stop at a random time, and waiting for the arrival of the next bus.">

<title>Angelo Maria Sabatini - Random incidence</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G7T7XXSXKG"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-G7T7XXSXKG', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Angelo Maria Sabatini</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/angelosabatini"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Archive</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Random incidence</h1>
  <div class="quarto-categories">
    <div class="quarto-category">probability</div>
  </div>
  </div>

<div>
  <div class="description">
    In this post, I briefly discuss the random incidence phenomenon, using the classical example of a person arriving at a bus stop at a random time, and waiting for the arrival of the next bus.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Angelo Maria Sabatini </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 22, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Consider the situation when the continuous time axis of our observations is partitioned into a sequence of interarrival intervals. With the term <em>arrival</em>, we designate the occurrence of everything we are interested to observe, for instance, a particle emitted from radioactive material and captured by a radiation counter, a message reaching its destination queue, maybe the bus that we are anxiously waiting for at the bus stop. Usually, probabilistic models that attempt to describe these different type of arrivals share the same assumption, namely the interarrival times (i.e., the times between successive arrivals) are independent random variables: for instance, the continuous-time Poisson process (hopefully, not the right model to predict the next bus arrival anyway!) is the case where the interarrival times are modeled as independent identically exponentially distributed random variables.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exponential distribution
</div>
</div>
<div class="callout-body-container callout-body">
<p>A continuous random variable <span class="math inline">\(X\)</span> is said to be exponential, or exponentially distributed with parameter <span class="math inline">\(\lambda\)</span>, when its cumulative distribution function (CDF) is written</p>
<p><span class="math display">\[
F_X(x)=\text{Pr}(X\leq x)=1-e^{-\lambda x},\;x\geq0
\]</span></p>
<p>The probability density function (PDF) is then given by:</p>
<p><span class="math display">\[
p_X(x)=\frac{d}{dx}F_X(x)=\lambda\,e^{-\lambda x},\;x\geq0
\]</span></p>
<p>The mean value, the mean square value and the variance of <span class="math inline">\(X\)</span> are:</p>
<p><span class="math display">\[
\left\{
\begin{split}
E[X]&amp;=\int_0^{\infty}xp_X(x)\,dx=\frac{1}{\lambda}\\
E[X^2]&amp;=\int_0^{\infty}x^2p_X(x)\,dx=\frac{2}{\lambda^2}\\
\text{Var}(X)&amp;=E[X^2]-E[X]^2=\frac{1}{\lambda^2}
\end{split}
\right.
\]</span></p>
<p>Integration by parts can be used to calculate the two expectations <span class="math inline">\(E[X]\)</span> and <span class="math inline">\(E[X^2]\)</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Poisson process
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider a sequence of independent exponential random variables <span class="math inline">\(T_1,T_2,T_3\cdots,\)</span> with common parameter <span class="math inline">\(\lambda\)</span>, and let these stand for the interarrival times. The arrivals are then recorded at times <span class="math inline">\(T_1,T_1+T_2,T_1+T_2+T_3,\cdots\)</span> and so forth, to define a continuous-time Poisson process.</p>
<p>A Poisson process is endowed with the following important properties:</p>
<ol type="1">
<li><p><strong>Independence of non-overlapping sets of times</strong>. This is a direct consequence of the assumed independence of the interarrival times.</p></li>
<li><p><strong>Fresh-start property</strong>. The part of the Poisson process that starts at any particular time <span class="math inline">\(t&gt;0\)</span> is a probabilistic replica of the Poisson process starting at time 0, and is independent of the part of the process prior to time <span class="math inline">\(t\)</span>. This can be seen as a special case of point 1.</p></li>
<li><p><strong>Memoryless interarrival time distribution</strong>. If <span class="math inline">\(T\)</span> is the time of the first arrival and if we know that <span class="math inline">\(T&gt;t\)</span>, then the remaining time <span class="math inline">\(T−t\)</span> is exponentially distributed, with the same parameter <span class="math inline">\(\lambda\)</span>:</p></li>
</ol>
<p><span class="math display">\[
\begin{split}
\text{Pr}(T&gt;t+s\,\vert\,T&gt;t)&amp;=\frac{\text{Pr}(T&gt;t+s,T&gt;t)}{\text{Pr}(T&gt;t)}\\
&amp;=\frac{\text{Pr}(T&gt;t+s)}{\text{Pr}(T&gt;t)}=\frac{1-F_T(t+s)}{1-F_T(t)}\\
&amp;=\frac{e^{-\lambda(t+s)}}{e^{-\lambda t}}=e^{-\lambda s}=\text{Pr}(T&gt;s)
\end{split}
\]</span></p>
<p>Properties 2.-3. can be rephrased saying that the ones whose life is modeled by an exponential distribution, well they should remain <em>forever young</em>: no matter how long they have lived so far, the remaining time to their death is predicted as if they are just born!</p>
</div>
</div>
<p>The term <strong>random incidence</strong> denotes the arrival of an observer at an arbitrary time <span class="math inline">\(t^*\)</span> into a <em>gap</em> between two consecutive arrivals in an arrival-type process that is not necessarily described by a Poisson model, <a href="#fig-fig1" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="fig-fig1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fig1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="random_incidence.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="450">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fig1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Illustration of the random incidence phenomenon.
</figcaption>
</figure>
</div>
<p>We are not saying that <span class="math inline">\(t^*\)</span> is random; in this regard, perhaps, using the term random incidence may appear misleading. However, the interval between the time of the previous arrival <span class="math inline">\(t_p\)</span> and <span class="math inline">\(t^*\)</span>, and the interval between <span class="math inline">\(t^*\)</span> and the time of the next arrival <span class="math inline">\(t_n\)</span> are random. All we need to state to start our discussion is to assume that the observer enters the arrival-type process in a situation when a previous arrival has surely occurred: probabilistically, the gap <span class="math inline">\(t_n-t_p\)</span> is then a well-defined quantity.</p>
<p>Suppose that we know the probability law of the interarrival times <span class="math inline">\(Y\)</span>. Let us denote by <span class="math inline">\(W\)</span> the random variable that describes the duration of the gap entered by random incidence, <span class="math inline">\(W=T_n-T_p\)</span>. Finally, we denote by <span class="math inline">\(T\)</span> the random variable that describes the waiting time for the next arrival from when the gap is entered by random incidence, <span class="math inline">\(T=T_n-T^*\)</span>.</p>
<p>It is argued that the probability that <span class="math inline">\(W\)</span> assumes a value between <span class="math inline">\(w\)</span> and <span class="math inline">\(w+dw\)</span> is proportional to both the the duration of the gap <span class="math inline">\(w\)</span> and the relative frequency of occurrence of such gaps <span class="math inline">\(p_Y(w)dw\)</span>:</p>
<p><span class="math display">\[
\text{Pr}(w\leq W\leq w+dw)=p_W(w)dw\propto w\,p_Y(w)dw
\]</span></p>
<p>Therefore:</p>
<p><span id="eq-eq1"><span class="math display">\[
p_W(w)=\frac{w\,p_Y(w)}{E[Y]}
\tag{1}\]</span></span></p>
<p>where the constant of proportionality is calculated to enforce the constraint of normalization for the PDF <span class="math inline">\(p_W(w)\)</span> of <span class="math inline">\(W\)</span> (its integral from 0 to infinity must be 1).</p>
<p>Now, given that a gap of length <span class="math inline">\(w\)</span> is entered by random incidence, we are equally likely to be anywhere within the gap. More precisely, <em>given</em> <span class="math inline">\(w\)</span>, the time until the next arrival <span class="math inline">\(T\)</span> has a uniform PDF:</p>
<p><span id="eq-eq2"><span class="math display">\[
p_{T\vert W}(t\,\vert\,w)=\frac{1}{w},\;0\leq t\leq w
\tag{2}\]</span></span></p>
<p>where <span class="math inline">\(p_{T\vert W}(t\,\vert\,w)\)</span> is the conditional PDF of <span class="math inline">\(T\)</span> given <span class="math inline">\(W\)</span>. Using <a href="#eq-eq1" class="quarto-xref">Equation&nbsp;1</a>, <a href="#eq-eq2" class="quarto-xref">Equation&nbsp;2</a> the joint PDF <span class="math inline">\(p_{TW}(t,w)\)</span> can be written:</p>
<p><span class="math display">\[
p_{TW}(t,w)=p_{T\vert W}(t\,\vert\,w)\,p_W(w)=\frac{p_Y(w)}{E[Y]},\;0\leq t\leq w&lt;\infty
\]</span></p>
<p>Finally, the marginal PDF <span class="math inline">\(p_T(t)\)</span> of the waiting time for the next arrival from when the gap is entered by random incidence can be formed simply by <em>integrating out</em> <span class="math inline">\(W\)</span>:</p>
<p><span id="eq-eq3"><span class="math display">\[
\boxed{p_T(t)=\int_{t}^{\infty}\frac{p_Y(w)}{E[Y]}dw=\frac{1-F_Y(t)}{E[Y]},\;t\geq0}
\tag{3}\]</span></span></p>
<div id="exm-exm1" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> Consider a bus passenger arriving at a bus stop. The probabilistic law of the bus headways <span class="math inline">\(F_Y(y)\)</span> will determine the probability law for the waiting time until the next bus arrives, <span class="math inline">\(p_T(t)\)</span> via <a href="#eq-eq3" class="quarto-xref">Equation&nbsp;3</a>, if we ignore interactions between successive buses and assume that the arrivals are identically distributed and independent.</p>
<p>Suppose that buses maintain perfect headways, being always spaced <span class="math inline">\(T_0\)</span> minutes apart:</p>
<p><span class="math display">\[
F_Y(y)=\left\{\begin{split}0&amp;\quad y&lt;T_0\\1&amp;\quad y\geq T_0\end{split}\right.\rightarrow p_Y(y)=\delta(y-T_0)\rightarrow E[Y]=T_0
\]</span></p>
<p>where the PDF is expressed in terms of a delta function located at time <span class="math inline">\(T_0\)</span>. The PDF of <span class="math inline">\(T\)</span> can be written:</p>
<p><span class="math display">\[
p_T(t)=\left\{\begin{split}&amp;\frac{1}{T_0}&amp;\quad 0\leq t\leq T_0\\&amp;0&amp;\quad t&gt;T_0\end{split}\right.\rightarrow E[T]=\frac{T_0}{2}
\]</span></p>
<p>As expected intuitively, the time until the next arrival, <em>given random incidence</em>, is uniformly distributed between <span class="math inline">\(0\)</span> and <span class="math inline">\(T_0\)</span>, with mean value <span class="math inline">\(E[T]=T_0/2\)</span>: if <span class="math inline">\(T_0=60\)</span> min the average waiting time is 30 min.</p>
<p>Now, suppose that the bus headways are on the hour, and fifteen minutes after the hour. Thus, the interarrival times alternate between 15 and 45 minutes. If the bus passenger shows up at the bus stop at any time uniformly distributed within a hour, she/he has to wait for an average time of 15/2 min (with probability 1/4) and 45/2 min (with probability 3/4):</p>
<p><span class="math display">\[
E[T]=\frac{15}{2}\cdot\frac{1}{4}+\frac{45}{2}\cdot\frac{3}{4}=18.75\;\text{min}
\]</span></p>
<p>More formally:</p>
<p><span class="math display">\[
F_Y(y)=\left\{\begin{split}0&amp;\quad0\leq y&lt;15\\1/2&amp;\quad15\leq y&lt;45\\1&amp;\quad y\geq45\end{split}\right.\rightarrow E[Y]=30\;\text{min}
\]</span></p>
<p>Using <a href="#eq-eq3" class="quarto-xref">Equation&nbsp;3</a>:</p>
<p><span class="math display">\[
p_T(t)=\left\{\begin{split}1/30&amp;\quad0\leq t&lt;15\\1/60&amp;\quad15\leq t&lt;45\\0&amp;\quad t\geq45\end{split}\right.\rightarrow E[T]=18.75\,\text{min}
\]</span></p>
<p>On average, the bus passenger has to wait longer than it might be expected taking into account <span class="math inline">\(E[Y]\)</span> only, namely <span class="math inline">\(E[Y]/2=15\)</span> min.</p>
<blockquote class="blockquote">
<p>This is because an observer who arrives at an arbitrary time, the bus passenger in this example, is more likely to fall in a large rather than a small interarrival interval: large interarrival intervals tend therefore to determine longer waiting times!</p>
</blockquote>
</div>
<div id="exm-exm2" class="theorem example">
<p><span class="theorem-title"><strong>Example 2</strong></span> Consider the (unrealistic) case that the bus headways are Poissonian. What does this mean? Basically, we state that the interarrival times are modeled by independent exponentially distributed random variables with rate <span class="math inline">\(\lambda\)</span> (the rate denotes the number of arrivals per unit time):</p>
<p><span class="math display">\[
F_Y(y)=1-e^{-\lambda t},\;t\geq 0\rightarrow p_Y(y)=\frac{F_Y(y)}{dy}=\lambda e^{-\lambda t},\;t\geq0\rightarrow E[Y]=1/\lambda
\]</span></p>
<p>Hence:</p>
<p><span class="math display">\[
p_T(t)=\lambda e^{-\lambda t},\;t\geq0
\]</span></p>
<p>Hence <span class="math inline">\(T\)</span> is exponentially distributed with rate <span class="math inline">\(\lambda\)</span>. The average time of waiting is <span class="math inline">\(E[T]=1/\lambda\)</span>. No matter when the event occurred, the observer who arrives at an arbitrary time <span class="math inline">\(t^*\)</span> (the bus passenger in this example) sees the Poisson process to start fresh at time <span class="math inline">\(t^*\)</span>, <a href="#fig-fig1" class="quarto-xref">Figure&nbsp;1</a>. It is worth noting that, according to the properties of independence, start-fresh and memorylessness stated above, we can run a Poisson process either forwards or backwards in time, without its properties are modified. Hence, not only <span class="math inline">\(T_n-T^*\)</span>, but also <span class="math inline">\(T^*-T_p\)</span> is exponentially distributed with parameter <span class="math inline">\(\lambda\)</span>. Moreover, <span class="math inline">\(T_n-T^*\)</span> and <span class="math inline">\(T_n-T^*\)</span> are independent. We have therefore established that the gap <span class="math inline">\(W\)</span> entered by random incidence is the sum of two independent exponential random variables with parameter <span class="math inline">\(\lambda\)</span>, with mean <span class="math inline">\(2/\lambda\)</span>. More formally, using <a href="#eq-eq1" class="quarto-xref">Equation&nbsp;1</a> we get:</p>
<p><span class="math display">\[
p_W(w)=\lambda w\,e^{-\lambda w},\;w\geq0
\]</span></p>
<p>We recall that the random variable <span class="math inline">\(X\)</span> Erlang of order <span class="math inline">\(k\)</span> has PDF:</p>
<p><span class="math display">\[
p(x)=\frac{\lambda^kx^{k-1}e^{-\lambda x}}{(k-1)!}
\]</span></p>
<p>In conclusion, the gap duration is a random variable Erlang of order 2.</p>
<blockquote class="blockquote">
<p>In a similar fashion to <a href="#exm-exm1" class="quarto-xref">Example&nbsp;1</a>, when landing into a Poisson process at an arbitrary time, we are more likely to fall in a large interarrival interval; the length of what we perceive as a <em>typical</em> interarrival interval is then greater than it is in reality.</p>
</blockquote>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="angelosabatini/blog.comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>