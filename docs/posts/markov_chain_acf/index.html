<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="">
<meta name="dcterms.date" content="2025-06-09">
<meta name="description" content="This post explores the computation of the stationary distribution and the autocorrelation function (ACF) in discrete-time Markov chains, focusing on two fundamental cases: a simple two-state chain and a more structured four-state chain that encodes second-order binary dependencies. Avoiding simulation-based methods, I’ll show how both analytical and numerical approaches can yield exact results for the ACF. Particular attention is given to the concept of Variance Inflation Factor (VIF) and its role in estimating the standard error of a sample proportion when autocorrelation is present.">

<title>Why memory matters: A tale of two Markov chains – Angelo Maria Sabatini</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-79108a0fc1995748cbd19a5b0e3e3e7c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G7T7XXSXKG"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-G7T7XXSXKG', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Angelo Maria Sabatini</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Archive</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/angelosabatini"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#the-two-state-markov-chain" id="toc-the-two-state-markov-chain" class="nav-link active" data-scroll-target="#the-two-state-markov-chain">The two-state Markov chain</a></li>
  <li><a href="#a-four-state-markov-chain-encoding-second-order-binary-dependencies" id="toc-a-four-state-markov-chain-encoding-second-order-binary-dependencies" class="nav-link" data-scroll-target="#a-four-state-markov-chain-encoding-second-order-binary-dependencies">A four-state Markov chain encoding second-order binary dependencies</a></li>
  <li><a href="#estimating-the-standard-error-of-a-sample-proportion" id="toc-estimating-the-standard-error-of-a-sample-proportion" class="nav-link" data-scroll-target="#estimating-the-standard-error-of-a-sample-proportion">Estimating the standard error of a sample proportion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Why memory matters: A tale of two Markov chains</h1>
  <div class="quarto-categories">
    <div class="quarto-category">probability</div>
    <div class="quarto-category">statistics</div>
  </div>
  </div>

<div>
  <div class="description">
    This post explores the computation of the stationary distribution and the autocorrelation function (ACF) in discrete-time Markov chains, focusing on two fundamental cases: a simple two-state chain and a more structured four-state chain that encodes second-order binary dependencies. Avoiding simulation-based methods, I’ll show how both analytical and numerical approaches can yield exact results for the ACF. Particular attention is given to the concept of Variance Inflation Factor (VIF) and its role in estimating the standard error of a sample proportion when autocorrelation is present.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="the-two-state-markov-chain" class="level2">
<h2 class="anchored" data-anchor-id="the-two-state-markov-chain">The two-state Markov chain</h2>
<p>Let us begin the discussion with the well-known two-state Markov chain (two-state MC) defined by the transition matrix:</p>
<p><span class="math display">\[
\mathbf{P} = \begin{bmatrix}
p_1 &amp; 1-p_1 \\
p_0 &amp; 1-p_0
\end{bmatrix}
\]</span></p>
<p><a href="#fig-1" class="quarto-xref">Figure&nbsp;1</a> show the graph representation of this two-state MC.</p>
<div id="fig-1" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="2-state-MC.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Graph representation of the two-state Markov chain used to encode the transition from two states <span class="math inline">\(S_0\)</span> and <span class="math inline">\(S_1\)</span>.
</figcaption>
</figure>
</div>
<p>Here, <span class="math inline">\(p_1\)</span> and <span class="math inline">\(p_0\)</span> represent the probabilities of remaining in state <span class="math inline">\(S_0\)</span> and moving from state <span class="math inline">\(S_1\)</span> to <span class="math inline">\(S_0\)</span>, respectively. Their complements, <span class="math inline">\(q_1 = 1 - p_1\)</span> and <span class="math inline">\(q_0 = 1 - p_0\)</span>, correspond to the probabilities of leaving <span class="math inline">\(S_0\)</span> and remaining in <span class="math inline">\(S_1\)</span>.</p>
<p>The conditions <span class="math inline">\(p_0, p_1 &gt; 0\)</span> ensure that the chain is both irreducible (any state can be reached from any other) and aperiodic (no strict periodic cycle is enforced), two structural properties that guarantee the existence of a stationary distribution. This stationary distribution reflects the long-run proportion of time the process spends in each state, and can be written as:</p>
<p><span class="math display">\[
\text{Pr}(S_0) = p, \quad \text{Pr}(S_1) = q = 1 - p
\]</span></p>
<p>Recall that the <span class="math inline">\(r\)</span>-step transition matrix, <span class="math inline">\(\mathbf{P}^{(r)}\)</span>, provides the probabilities of transitioning from each state to any other state in exactly <span class="math inline">\(r\)</span> steps. In the case of the two-state MC introduced above, it is known that this matrix admits the following elegant closed-form expression:</p>
<p><span class="math display">\[
\mathbf{P}^{(r)} = \frac{1}{1 - (p_1 - p_0)}
\begin{bmatrix}
p_0 &amp; q_1 \\
p_0 &amp; q_1
\end{bmatrix}
+ \frac{(p_1 - p_0)^r}{1 - (p_1 - p_0)}
\begin{bmatrix}
q_1 &amp; -q_1 \\
-p_0 &amp; p_0
\end{bmatrix}
\]</span></p>
<p>This decomposition separates the long-run behavior (first term) from the transient dynamics (second term), which decays geometrically as <span class="math inline">\((p_1 - p_0)^r\)</span>. In other words, the process progressively “forgets” its initial state, and the transition probabilities stabilize over time.</p>
<p>This convergence is a hallmark of well-behaved Markov chains and underlies the existence of a unique stationary distribution:</p>
<p><span class="math display">\[
\boldsymbol{\pi} = \frac{1}{1 - (p_1 - p_0)} [p_0 \;\; q_1]
\]</span></p>
<p>This stationary distribution satisfies the fundamental balance condition <span class="math inline">\(\boldsymbol{\pi} \mathbf{P} = \boldsymbol{\pi}\)</span> and it characterizes the long-run proportion of time the process spends in each state — independently of the starting configuration.</p>
<p>We are now interested in the properties of the stochastic process <span class="math inline">\(\{X_t\}\)</span> generated by this chain, where <span class="math inline">\(X_t\)</span> denotes the state occupied by the process at time <span class="math inline">\(t\)</span>. Since the chain evolves over two discrete states, this process is binary, and its behavior can be fully characterized by its first and second-order moments, including the autocorrelation function (ACF).</p>
<p>Assuming that the states <span class="math inline">\(S_0\)</span> and <span class="math inline">\(S_1\)</span> are coded as <span class="math inline">\(\{1, 0\}\)</span>, the expectation and variance of the process <span class="math inline">\(X_t\)</span> are:</p>
<p><span class="math display">\[
\begin{aligned}
E[X_t] &amp;= \pi_1 = \dfrac{p_0}{1 - (p_1 - p_0)} \\
\text{Var}(X_t) &amp;= E[X_t^2] - E[X_t]^2 = E[X_t] - E[X_t]^2 \\
&amp;= \pi_1 - \pi_1^2 = \dfrac{p_0 q_1}{\left[1 - (p_1 - p_0)\right]^2}
\end{aligned}
\]</span></p>
<p>To compute the ACF at lag <span class="math inline">\(r\)</span>, note that only the case <span class="math inline">\(X_t = 1, X_{t+r} = 1\)</span> contributes to <span class="math inline">\(E[X_t X_{t+r}]\)</span>, due to the binary coding:</p>
<p><span class="math display">\[
\begin{aligned}
E[X_t X_{t+r}] &amp;= \sum_{i,j} i \cdot j \cdot \Pr(X_t = i, X_{t+r} = j) \\
&amp;= \Pr(X_t = 1, X_{t+r} = 1) = \pi_1 \cdot P^{(r)}_{11}
\end{aligned}
\]</span></p>
<p>The covariance at lag <span class="math inline">\(r\)</span> is therefore:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Cov}(X_t, X_{t+r}) &amp;= E[X_t X_{t+r}] - E[X_t]^2 \\
&amp;= \pi_1 \cdot P^{(r)}_{11} - \pi_1^2 \\
&amp;= (p_1 - p_0)^r \cdot \frac{p_0 q_1}{[1 - (p_1 - p_0)]^2}
\end{aligned}
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A note on the variance computation
</div>
</div>
<div class="callout-body-container callout-body">
<p>Since <span class="math inline">\(X_t \in \{0,1\}\)</span>, it follows that <span class="math inline">\(X_t^2 = X_t\)</span> for all <span class="math inline">\(t\)</span>, and hence <span class="math inline">\(E[X_t^2] = E[X_t]\)</span>. This identity simplifies the computation of the variance, which becomes <span class="math inline">\(\text{Var}(X_t) = E[X_t] - E[X_t]^2\)</span>.</p>
</div>
</div>
<p>The ACF is:</p>
<p><span class="math display">\[
\boxed{\rho_r = \text{Corr}(X_t, X_{t+r}) = \frac{\text{Cov}(X_t, X_{t+r})}{\text{Var}(X_t)} = (p_1 - p_0)^r}
\]</span></p>
<p>This geometric decay reflects the memory of the chain, governed by the second eigenvalue of the transition matrix <span class="math inline">\(\mathbf{P}\)</span>, namely <span class="math inline">\(\lambda_2 = p_1 - p_0\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Coding and autocorrelation
</div>
</div>
<div class="callout-body-container callout-body">
<p>The ACF derived above is based on a binary coding of the process <span class="math inline">\(X_t \in \{0,1\}\)</span>. In this setting, the autocovariance at lag <span class="math inline">\(r\)</span> is:</p>
<p><span class="math display">\[
\text{Cov}(X_t, X_{t+r}) = E[X_t X_{t+r}] - E[X_t]^2
\]</span></p>
<p>and the ACF is obtained as:</p>
<p><span class="math display">\[
\rho_r = \frac{\text{Cov}(X_t, X_{t+r})}{\text{Var}(X_t)} = (p_1 - p_0)^r
\]</span></p>
<p>Now, suppose we recode the process using values <span class="math inline">\(\{-1, +1\}\)</span>, defining <span class="math inline">\(Z_t = 2X_t - 1\)</span>. Then <span class="math inline">\(Z_t \in \{-1, +1\}\)</span> and:</p>
<p><span class="math display">\[
\begin{aligned}
E[Z_t] &amp;= 2E[X_t] - 1 \\
\text{Var}(Z_t) &amp;= 4 \cdot \text{Var}(X_t) \\
E[Z_t Z_{t+r}] &amp;= 4E[X_t X_{t+r}] - 4E[X_t] + 1
\end{aligned}
\]</span></p>
<p>So the autocovariance of <span class="math inline">\(Z_t\)</span> becomes:</p>
<p><span class="math display">\[
\text{Cov}(Z_t, Z_{t+r}) = E[Z_t Z_{t+r}] - E[Z_t]^2 = 4 \cdot \text{Cov}(X_t, X_{t+r})
\]</span></p>
<p>and the autocorrelation remains invariant:</p>
<p><span class="math display">\[
\text{Corr}(Z_t, Z_{t+r}) = \frac{\text{Cov}(Z_t, Z_{t+r})}{\text{Var}(Z_t)} = \frac{4 \cdot \text{Cov}(X_t, X_{t+r})}{4 \cdot \text{Var}(X_t)} = \rho_r
\]</span></p>
<p>This means that while the numerical values of expectation, variance, and autocovariance change under linear recoding, the autocorrelation (a dimensionless, normalized measure) does not.</p>
</div>
</div>
</section>
<section id="a-four-state-markov-chain-encoding-second-order-binary-dependencies" class="level2">
<h2 class="anchored" data-anchor-id="a-four-state-markov-chain-encoding-second-order-binary-dependencies">A four-state Markov chain encoding second-order binary dependencies</h2>
<p>Now consider a more structured chain where the state at time <span class="math inline">\(t\)</span> depends on both <span class="math inline">\(X_{t-1}\)</span> and <span class="math inline">\(X_{t-2}\)</span>. This can be seen as a natural extension of the two-state MC to capture memory over two steps. This corresponds to a second-order Markov chain on binary values <span class="math inline">\(X_t \in {0,1}\)</span>. It can be encoded as a first-order Markov chain with 4 states (four-state MC), each representing a pair (<span class="math inline">\(X_{t-2}, X_{t-1}\)</span>):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>state</th>
<th>pair</th>
<th><span class="math inline">\(X_t\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(S_0\)</span></td>
<td>(0,0)</td>
<td>0</td>
</tr>
<tr class="even">
<td><span class="math inline">\(S_1\)</span></td>
<td>(0,1)</td>
<td>1</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(S_2\)</span></td>
<td>(1,0)</td>
<td>0</td>
</tr>
<tr class="even">
<td><span class="math inline">\(S_3\)</span></td>
<td>(1,1)</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>The transition matrix <span class="math inline">\(\mathbf{P} \in \mathbb{R}^{4 \times 4}\)</span> then takes the form:</p>
<p><span class="math display">\[
\mathbf{P} = \begin{bmatrix}
p_{11} &amp; 1 - p_{11} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; p_{10} &amp; 1 - p_{10} \\
p_{01} &amp; 1 - p_{01} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; p_{00} &amp; 1 - p_{00}
\end{bmatrix}
\]</span></p>
<p>Each row corresponds to a transition determined by the current pair (<span class="math inline">\(X_{t-2}, X_{t-1}\)</span>), and the choice of the next value <span class="math inline">\(X_t\)</span> determines the new state <a href="#fig-2" class="quarto-xref">Figure&nbsp;2</a>.</p>
<div id="fig-2" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="4-state-MC.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Graph representation of the four-state Markov chain used to encode the particular alternation structure represented by the transition matrix <span class="math inline">\(\mathbf{P}\)</span>.
</figcaption>
</figure>
</div>
<section id="stationary-distribution" class="level3">
<h3 class="anchored" data-anchor-id="stationary-distribution">Stationary distribution</h3>
<p>We can compute the stationary distribution <span class="math inline">\(\boldsymbol{\pi} = [\pi_0, \pi_1, \pi_2, \pi_3]\)</span> by solving the system:</p>
<p><span class="math display">\[
\boldsymbol{\pi} \cdot \mathbf{P} = \boldsymbol{\pi}, \quad \sum_{i=0}^3 \pi_i = 1
\]</span></p>
<p>Thanks to the sparsity and regularity of the transition matrix <span class="math inline">\(\mathbf{P}\)</span>, this system admits a closed-form solution. In particular, the stationary probabilities satisfy the following relations:</p>
<p><span class="math display">\[
\begin{aligned}
\pi_1 &amp;= \frac{1 - p_{11}}{p_{01}}\pi_0 \\
\pi_2 &amp;= \pi_1 \\
\pi_3 &amp;= \frac{1 - p_{10}}{p_{00}}\pi_1
\end{aligned}
\]</span></p>
<p>Substituting into the normalization condition gives:</p>
<p><span class="math display">\[
\left[ 1 + \frac{2(1 - p_{11})}{p_{01}} + \frac{(1 - p_{11})(1 - p_{10})}{p_{01} p_{00}} \right]\pi_0 = 1
\]</span></p>
<p>Once <span class="math inline">\(\pi_0\)</span> is computed from this expression, all remaining <span class="math inline">\(\pi_i\)</span>, <span class="math inline">\(i = 1, \dots, 3\)</span>, follow directly.</p>
</section>
<section id="autocorrelation-function" class="level3">
<h3 class="anchored" data-anchor-id="autocorrelation-function">Autocorrelation function</h3>
<p>To compute the ACF, we first define a projection function <span class="math inline">\(f(i)\)</span>, which recovers the binary value <span class="math inline">\(X_t\)</span> encoded by state <span class="math inline">\(S_i\)</span>:</p>
<p><span class="math display">\[
f(i) = \begin{cases}
1 &amp; \text{if } i \in \{1, 3\} \\
0 &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Then, the expectation of <span class="math inline">\(X_t\)</span> is:</p>
<p><span class="math display">\[
E[X_t] = \sum_{i=0}^3 f(i) \cdot \pi_i = \pi_1 + \pi_3
\]</span></p>
<p>and the variance becomes:</p>
<p><span class="math display">\[
\text{Var}(X_t) = E[X_t](1 - E[X_t])
\]</span></p>
<p>To evaluate the autocorrelation at lag <span class="math inline">\(r\)</span>, we compute the joint moment:</p>
<p><span class="math display">\[
E[X_t X_{t+r}] = \sum_{i=0}^3 \sum_{j=0}^3 f(i) \cdot f(j) \cdot \pi_i \cdot \left[\mathbf{P}^r\right]_{ij}
\]</span></p>
<p>so that the ACF is:</p>
<p><span class="math display">\[
\rho_r = \dfrac{E[X_t X_{t+r}] - E[X_t]^2}{\text{Var}(X_t)}
\]</span></p>
<p>This method relies only on the stationary distribution and the <span class="math inline">\(r\)</span>-step transition matrix <span class="math inline">\(\mathbf{P}^r\)</span>. Unlike the two-state MC discussed above, here <span class="math inline">\(\mathbf{P}^r\)</span> does not admit a closed-form expression and must be computed numerically.</p>
<p>The following R function implements the numerical computation of the ACF for the four-state MC described above. It constructs the transition matrix, solves for the stationary distribution, and computes the projected ACF based on the binary encoding of the states.</p>
<div class="cell">
<details class="code-fold">
<summary>Numerical computation of ACF</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>compute_acf_four_state <span class="ot">&lt;-</span> <span class="cf">function</span>(p11, p10, p01, p00, <span class="at">max_lag =</span> <span class="dv">10</span>) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Transition matrix</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  P <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(p11, <span class="dv">1</span> <span class="sc">-</span> p11, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>, <span class="dv">0</span>, p10, <span class="dv">1</span> <span class="sc">-</span> p10,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                p01, <span class="dv">1</span> <span class="sc">-</span> p01, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span>, <span class="dv">0</span>, p00, <span class="dv">1</span> <span class="sc">-</span> p00), <span class="at">nrow =</span> <span class="dv">4</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Solve for stationary distribution π such that π %*% P = π</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  A <span class="ot">&lt;-</span> <span class="fu">t</span>(P) <span class="sc">-</span> <span class="fu">diag</span>(<span class="dv">4</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  A <span class="ot">&lt;-</span> <span class="fu">rbind</span>(A, <span class="fu">rep</span>(<span class="dv">1</span>, <span class="dv">4</span>))             <span class="co"># Add normalization row</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>), <span class="dv">1</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  pi <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(A) <span class="sc">%*%</span> A, <span class="fu">t</span>(A) <span class="sc">%*%</span> b)  <span class="co"># Least-squares solution</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Projection function f(i) = 1 for states 1 and 3, else 0</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  f <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  EX   <span class="ot">&lt;-</span> <span class="fu">sum</span>(f <span class="sc">*</span> pi)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  VarX <span class="ot">&lt;-</span> EX <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> EX)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  rho <span class="ot">&lt;-</span> <span class="fu">numeric</span>(max_lag)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  P_power <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">4</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (r <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>max_lag) {</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    P_power <span class="ot">&lt;-</span> P_power <span class="sc">%*%</span> P</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    EXX <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        EXX <span class="ot">&lt;-</span> EXX <span class="sc">+</span> f[i] <span class="sc">*</span> f[j] <span class="sc">*</span> pi[i] <span class="sc">*</span> P_power[i, j]</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    rho[r] <span class="ot">&lt;-</span> (EXX <span class="sc">-</span> EX<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> VarX</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="at">pi   =</span> <span class="fu">round</span>(pi, <span class="dv">5</span>),</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="at">EX   =</span> <span class="fu">round</span>(EX, <span class="dv">5</span>),</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="at">VarX =</span> <span class="fu">round</span>(VarX, <span class="dv">5</span>),</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="at">rho   =</span> <span class="fu">round</span>(rho, <span class="dv">5</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#fig-3" class="quarto-xref">Figure&nbsp;3</a> shows the resulting autocorrelation pattern, which reflects the alternating behavior encoded in the four-state structure and highlights the persistence introduced by second-order dependencies.</p>
<div id="fig-3" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="fig_acf.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Autocorrelation function for the four-state Markov chain with parameters <span class="math inline">\(p_{00} = 0.80, p_{01} = 0.20, p_{10} = 0.50, p_{11} = 0.10\)</span>.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="estimating-the-standard-error-of-a-sample-proportion" class="level2">
<h2 class="anchored" data-anchor-id="estimating-the-standard-error-of-a-sample-proportion">Estimating the standard error of a sample proportion</h2>
<p>When working with binary time series, a fundamental question is how to estimate the standard error (SE) of the sample proportion</p>
<p><span class="math display">\[
\bar{X}_n = \dfrac{1}{n}\sum_{t=1}^n X_t
\]</span></p>
<p>In the case of independent Bernoulli trials, the variance of the sample mean <span class="math inline">\(\bar{X}_n\)</span> is:</p>
<p><span class="math display">\[
\text{Var}(\bar{X}_n) = \frac{\sigma^2}{n}, \quad \text{with } \sigma^2 = p(1 - p)
\]</span></p>
<p>and the corresponding standard error is:</p>
<p><span class="math display">\[
\text{SE} = \sqrt{\dfrac{p(1-p)}{n}}
\]</span></p>
<p>However, when the data are generated from a dependent process such as a Markov chain (either order 1 or 2), this formula underestimates the true SE, because the observations are no longer independent.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variance of the sample mean with autocorrelated data
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let <span class="math inline">\({X_t}\)</span> be a weakly stationary process with mean <span class="math inline">\(\mu\)</span>, variance <span class="math inline">\(\sigma^2\)</span>, and autocovariance function <span class="math inline">\(\gamma_r = \text{Cov}(X_t, X_{t+r})\)</span>.</p>
<p>We are interested in the variance of the sample mean, which can be written:</p>
<p><span class="math display">\[
\text{Var}(\bar{X}_n) = \frac{1}{n^2} \sum_{t=1}^n \sum_{s=1}^n \text{Cov}(X_t, X_s)
= \frac{1}{n^2} \sum_{t=1}^n \sum_{s=1}^n \gamma_{|t-s|}
\]</span></p>
<p>We now reorganize this sum by collecting all terms with the same lag <span class="math inline">\(r = \mid t - s\,\mid\)</span>. The number of terms with lag <span class="math inline">\(r\)</span> is <span class="math inline">\(n - r\)</span> (for <span class="math inline">\(r = 0, 1,\cdots,n - 1\)</span>). So:</p>
<p><span class="math display">\[
\text{Var}(\bar{X}_n) = \frac{1}{n^2} \sum_{r=-(n-1)}^{n-1} (n - |r|) \gamma_{|r|}
= \frac{1}{n^2} \left( n \gamma_0 + 2 \sum_{r=1}^{n-1} (n - r) \gamma_r \right)
\]</span></p>
<p>Finally, using <span class="math inline">\(\gamma_0 = \sigma^2\)</span> and dividing numerator and denominator by <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[
\text{Var}(\bar{X}_n) = \frac{\sigma^2}{n} \underbrace{\left(1 + 2 \sum_{r=1}^{n-1} \left(1 - \frac{r}{n}\right) \rho_r \right)}_\text{VIF}
\]</span></p>
<p>This formula shows how the autocorrelation structure inflates the variance of the sample mean. The term in parentheses is usually referred to as the variance inflation factor (<span class="math inline">\(\text{VIF}\)</span>). <span class="math inline">\(\text{VIF}\)</span> reduces to 1 in the i.i.d. (independent identically distributed) case, when all <span class="math inline">\(\rho_r = 0\)</span> for <span class="math inline">\(r \geq 1\)</span>.</p>
<p>For large <span class="math inline">\(n\)</span> and fast decay of the ACF, a common simplification for <span class="math inline">\(\text{VIF}\)</span> applies:</p>
<p><span class="math display">\[
\text{VIF} \approx 1 + 2 \sum_{r=1}^R \rho_r
\]</span></p>
<p>where <span class="math inline">\(R\)</span> is a cutoff lag beyond which autocorrelation is negligible.</p>
</div>
</div>
<p>With the introduction of the <span class="math inline">\(\text{VIF}\)</span>, the expression of <span class="math inline">\(\text{SE}\)</span> becomes:</p>
<p><span class="math display">\[
\boxed{\text{SE} = \sqrt{\dfrac{p(1-p)}{n}} \sqrt{\text{VIF}\mathstrut}}
\]</span></p>
<p>The <span class="math inline">\(\text{VIF}\)</span> can be computed for both the two-state and four-state MCs, for example when estimating the proportion of time spent in each state — and its standard error — from an observed binary sequence of length <span class="math inline">\(n\)</span>.</p>
<ul>
<li>In the two-state MC, define the transition probabilities as follows:</li>
</ul>
<p><span class="math display">\[
p_0 = \text{Pr}(0 \to 1), \quad p_1 = \text{Pr}(1 \to 1)
\]</span></p>
<p>With this parametrization, the lag-<span class="math inline">\(r\)</span> autocorrelation of the process is:</p>
<p><span class="math display">\[
\rho_r = (p_1 - p_0)^r
\]</span></p>
<p>This expression fully determines the ACF, which decays geometrically. The corresponding <span class="math inline">\(\text{VIF}\)</span> becomes:</p>
<p><span class="math display">\[
\text{VIF} = \frac{1 + \rho_1}{1 - \rho_1} = \frac{1 + (p_1 - p_0)}{1 - (p_1 - p_0)}
\]</span></p>
<p>In the two-state case, the process is i.i.d. only when the transition matrix is both symmetric and memoryless — that is, when transitions occur with equal probability in both directions. In this case, the autocorrelations vanish and <span class="math inline">\(\text{VIF} = 1\)</span>.</p>
<ul>
<li>In the four-state MC, the autocorrelations <span class="math inline">\(\rho_r\)</span> must be computed numerically (as done above), and plugged into the expression for <span class="math inline">\(\text{VIF}\)</span> above. As shown in <a href="#fig-3" class="quarto-xref">Figure&nbsp;3</a>, the ACF decays fast enough to justify using the simplified formula above.</li>
</ul>
<p>In both cases, accounting for autocorrelation is essential to avoid underestimating uncertainty in sample-based inference.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Example. Comparing VIF in two-state and four-state MCs">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example. Comparing VIF in two-state and four-state MCs
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let us consider two different Markov models generating a binary sequence <span class="math inline">\({X_t}\)</span>:</p>
<ul>
<li><p>two-state MC directly over <span class="math inline">\(\{0,1\}\)</span>,</p></li>
<li><p>four-state MC, which overlaps bigrams <span class="math inline">\((X_{t-1}, X_t) \in \{00,01,10,11\}\)</span>, where the actual sequence is recovered by projecting on the second element of each pair.</p></li>
</ul>
<p>The two-state MC has transition parameters:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
p_0&amp;=0.665\\
p_1&amp;=0.115
\end{aligned}
\right.
\]</span></p>
<p>Hence, the stationary distribution is given by:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\text{Pr}(X_t=0)&amp;=\dfrac{p_0}{1-(p_1-p_0)}=0.429\\
\text{Pr}(X_t=1)&amp;=\dfrac{1-p_1}{1-(p_1-p_0)}=0.571
\end{aligned}
\right.
\]</span></p>
<p>The four-state MC has transition parameters:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
p_{00}&amp;= 0.86\\
p_{01}&amp;= 0.12\\
p_{10}&amp;= 0.56\\
p_{11}&amp;= 0.12
\end{aligned}
\right.
\]</span></p>
<p>The stationary distribution of the binary sequence is computed by projecting on the second digit of each pair:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\text{Pr}(X_t=0)&amp;= \pi_0+\pi_2\approx 0.429\\
\text{Pr}(X_t=1)&amp;= \pi_1+\pi_3\approx 0.571\\
\end{aligned}
\right.
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\pi} = [\pi_0, \pi_1, \pi_2, \pi_3]\)</span> is the stationary distribution of the four-state MC (obtained from, e.g., <code>compute_acf_four_state()</code>).</p>
<p>Even if the marginal distributions are almost identical, the two models may produce very different autocorrelation structures, and hence different values of the <span class="math inline">\(\text{VIF}\)</span>:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
\text{VIF}_{\text{two-state}}&amp;=\dfrac{1+(p_1-p_0)}{1-(p_1-p_0)}=0.290\\
\text{VIF}_{\text{four-state}}&amp;=0.196
\end{aligned}
\right.
\]</span></p>
<p>where the value of <span class="math inline">\(\text{VIF}_{\text{four-state}}\)</span> is obtained from <code>compute_acf_four_state()</code>).</p>
</div>
</div>
<p>This example illustrates how two Markov models generating binary sequences with identical marginal distributions can nevertheless lead to different effective sample sizes, due to distinct autocorrelation structures that significantly impact inference.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>To achieve the same standard error in both settings, one would need to inflate the sample size in the more autocorrelated case by a factor approximately equal to the ratio of the corresponding <span class="math inline">\(\text{VIF}\)</span>s. In the example above, since <span class="math inline">\(\text{VIF}{\text{two-state}} = 0.290\)</span> and <span class="math inline">\(\text{VIF}{\text{four-state}} = 0.196\)</span>, the required sample size under the four-state model should be roughly 1.5 times larger to achieve the same standard error as under the two-state model.</p>
</div>
</div>
<blockquote class="blockquote">
<p><strong>In short, correlation matters—even when proportions look the same.</strong> These insights remind us that dependencies in data—often subtle—can have major consequences for statistical inference. Understanding and quantifying them is essential, even in the simplest of models.</p>
</blockquote>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/amsabatini\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="angelosabatini/blog.comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>