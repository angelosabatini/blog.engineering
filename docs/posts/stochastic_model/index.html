<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Angelo Maria Sabatini">
<meta name="dcterms.date" content="2026-02-02">
<meta name="description" content="Using a minimal kinematic model, this post examines how assumptions on stochastic acceleration propagate from continuous time to an exact discrete-time model of position and velocity. The focus is on modeling choices, discretization, and their often overlooked consequences for uncertainty representation.">

<title>Discretizing motion under stochastic acceleration ‚Äì Angelo Maria Sabatini</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-79108a0fc1995748cbd19a5b0e3e3e7c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G7T7XXSXKG"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-G7T7XXSXKG', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  
<link rel="alternate" type="application/rss+xml" title="Angelo Maria Sabatini ‚Äì Blog RSS" href="../../blog.xml">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Angelo Maria Sabatini</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Archive</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/angelosabatini"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img" aria-label="RSS feed">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link active" data-scroll-target="#problem-statement">Problem statement</a></li>
  <li><a href="#the-motion-model" id="toc-the-motion-model" class="nav-link" data-scroll-target="#the-motion-model">The motion model</a></li>
  <li><a href="#the-discrete-time-input-covariance-q_d" id="toc-the-discrete-time-input-covariance-q_d" class="nav-link" data-scroll-target="#the-discrete-time-input-covariance-q_d">The discrete-time input covariance <span class="math inline">\(Q_d\)</span></a></li>
  <li><a href="#white-noise-acceleration-as-a-limiting-model" id="toc-white-noise-acceleration-as-a-limiting-model" class="nav-link" data-scroll-target="#white-noise-acceleration-as-a-limiting-model">White noise acceleration as a limiting model</a>
  <ul class="collapse">
  <li><a href="#on-simulation-and-sample-paths" id="toc-on-simulation-and-sample-paths" class="nav-link" data-scroll-target="#on-simulation-and-sample-paths">On simulation and sample paths</a></li>
  <li><a href="#a-conceptual-remark-on-dimensions-and-modeling" id="toc-a-conceptual-remark-on-dimensions-and-modeling" class="nav-link" data-scroll-target="#a-conceptual-remark-on-dimensions-and-modeling">A conceptual remark on dimensions and modeling</a></li>
  <li><a href="#a-final-remark-on-the-role-of-the-sampling-interval" id="toc-a-final-remark-on-the-role-of-the-sampling-interval" class="nav-link" data-scroll-target="#a-final-remark-on-the-role-of-the-sampling-interval">A final remark on the role of the sampling interval</a></li>
  </ul></li>
  <li><a href="#concluding-remarks" id="toc-concluding-remarks" class="nav-link" data-scroll-target="#concluding-remarks">Concluding remarks</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Discretizing motion under stochastic acceleration</h1>
  <div class="quarto-categories">
    <div class="quarto-category">stochastic modeling</div>
  </div>
  </div>

<div>
  <div class="description">
    Using a minimal kinematic model, this post examines how assumptions on stochastic acceleration propagate from continuous time to an exact discrete-time model of position and velocity. The focus is on modeling choices, discretization, and their often overlooked consequences for uncertainty representation.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Angelo Maria Sabatini </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 2, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>üíæ <strong>Prefer reading offline?</strong> You can <a href="stochastic_model.pdf">download a PDF version of this post</a> for printing or future reference.</p>
</blockquote>
<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem statement</h2>
<p>Consider the simplest possible problem in Newtonian kinematics: the motion of a point along a straight line. Its position, velocity and acceleration are denoted by <span class="math inline">\(x(t), v(t)\)</span> and <span class="math inline">\(a(t)\)</span>, respectively. The equations of motion are elementary:</p>
<p><span id="eq-eq1"><span class="math display">\[
\left\{
\begin{align}
\dot{x}(t)&amp;=v(t)\\
\ddot{x}(t)&amp;=\dot{v}(t)=a(t)
\end{align}
\right.
\tag{1}\]</span></span></p>
<p>Here and throughout the post, the dot notation denotes differentiation with respect to time.</p>
<p>If the acceleration is known as a deterministic function of time, the solution is trivial: integrate once to obtain the velocity, and integrate again to obtain the position, starting from known initial conditions.</p>
<p>In many practical problems, however, acceleration is unknown. Examples abound:</p>
<ul>
<li>a vehicle subject to unpredictable maneuvers,</li>
<li>a moving object affected by small, unmodeled disturbances,</li>
<li>a target whose motion can only be described approximately.</li>
</ul>
<p>In all these cases, acceleration must be modeled, rather than specified explicitly. This raises the apparently simple question of how the acceleration should be represented.</p>
<p>At first sight, the answer seems obvious: treat acceleration as a stochastic process, that is, specify the statistical rules governing its time evolution. More precisely, acceleration can often be described as the superposition of deterministic and stochastic components. For instance, a known nominal motion‚Äîsuch as constant velocity or constant acceleration‚Äîmay be affected by unpredictable perturbations. In this post, the focus is on the stochastic component alone, in order to isolate and understand its effect on the statistical properties of position (and velocity).</p>
<p>Even when the equations of motion are trivial, the modeling choices for the input <span class="math inline">\(a(t)\)</span> have profound consequences ‚Äî especially when we recall that, while the motion of the point naturally occurs in continuous time, in practice we study it in discrete-time:</p>
<ul>
<li>measurement data are sampled,</li>
<li>tracking algorithms operate on sequences rather than continuous trajectories,</li>
<li>computer simulations are run with a fixed time step.</li>
</ul>
<p>When the input to the system is deterministic, this passage is straightforward. However, when the input is stochastic, the transition from continuous time to discrete time can become surprisingly subtle.</p>
<p>This post is about understanding what it really means to discretize <a href="#eq-eq1" class="quarto-xref">Equation&nbsp;1</a> when <span class="math inline">\(a(t)\)</span> is modeled as a stochastic process. The goal of this post is to show that, while the physical problem is simple, the associated modeling choices are not trivial.</p>
</section>
<section id="the-motion-model" class="level2">
<h2 class="anchored" data-anchor-id="the-motion-model">The motion model</h2>
<p>Before introducing any stochastic description, it is useful to clarify what is given and what is unknown in the motion model itself.</p>
<p>The kinematic structure of the problem is completely known. The relationships between position, velocity, and acceleration are fixed by Newtonian kinematics, as shown in <a href="#eq-eq1" class="quarto-xref">Equation&nbsp;1</a>. From a systems point of view, <span class="math inline">\(a(t)\)</span> is not treated as a state variable, but as an external input to an otherwise deterministic system.</p>
<p>Because velocity and position are obtained by integrating acceleration, any assumption made on the acceleration propagates through the system. Small differences in how acceleration is modeled can result in large differences in the statistical properties of position and velocity, once the model is discretized.</p>
<p>The state of the system described by <a href="#eq-eq1" class="quarto-xref">Equation&nbsp;1</a> is defined as:</p>
<p><span id="eq-eq2"><span class="math display">\[
\mathbf{x}(t) \triangleq \begin{bmatrix} x(t) \\ v(t) \end{bmatrix}
\tag{2}\]</span></span></p>
<p>The continuous-time kinematic model is:</p>
<p><span id="eq-eq3"><span class="math display">\[
\dot{\mathbf{x}}(t) = A\,\mathbf{x}(t) + B\,a(t)
\tag{3}\]</span></span></p>
<p>with:</p>
<p><span id="eq-eq4"><span class="math display">\[
A=\begin{bmatrix}0&amp;1\\0&amp;0\end{bmatrix},\;
B=\begin{bmatrix}0\\1\end{bmatrix}
\tag{4}\]</span></span></p>
<p>Consider sampling the motion at times <span class="math inline">\(t_k = kT\)</span>, with sampling interval <span class="math inline">\(T\)</span>. For any input <span class="math inline">\(a(t)\)</span> (deterministic or stochastic), the exact solution at the sampling instants <span class="math inline">\(t_k=kT\)</span> is:</p>
<p><span id="eq-eq5"><span class="math display">\[
\mathbf{x}_{k+1} = e^{AT}\,\mathbf{x}_k + \mathbf{u}_k,
\tag{5}\]</span></span></p>
<p>where the state transition matrix is</p>
<p><span id="eq-eq6"><span class="math display">\[
e^{AT} = \begin{bmatrix}
1 &amp; T\\
0 &amp; 1
\end{bmatrix}
\tag{6}\]</span></span></p>
<p>and the input vector <span class="math inline">\(\mathbf{u}_k\)</span> can be written:</p>
<p><span id="eq-eq7"><span class="math display">\[
\mathbf{u}_k = \int_{0}^{T} e^{A(T-\tau)}\,B\,a(t_k+\tau)\,d\tau
\tag{7}\]</span></span></p>
<p>This is a standard result in systems theory: discretization affects the deterministic state transition through the matrix exponential <span class="math inline">\(e^{AT}\)</span>, while the input contributes through an integral that ‚Äúaccumulates‚Äù its effect over the sampling interval.</p>
<p>It is worth noting that the discrete-time representation in <a href="#eq-eq5" class="quarto-xref">Equation&nbsp;5</a>, with <span class="math inline">\(e^{AT}\)</span> as in <a href="#eq-eq6" class="quarto-xref">Equation&nbsp;6</a> and <span class="math inline">\(\mathbf{u}_k\)</span> as in <a href="#eq-eq7" class="quarto-xref">Equation&nbsp;7</a>, is exact at the sampling times <span class="math inline">\(kT\)</span> and holds regardless of how acceleration is modeled. What is still unspecified is the statistical characterization of <span class="math inline">\(\mathbf{u}_k\)</span>, which depends entirely on the modeling assumptions made for <span class="math inline">\(a(t)\)</span>.</p>
<p>Different assumptions on the time evolution of acceleration (for instance, whether it is memoryless or correlated) lead to different statistical properties of <span class="math inline">\(\mathbf{u}_k\)</span>, and therefore to different statistical properties of the state <span class="math inline">\(\mathbf{x}_k\)</span> at the sampling times. In particular, the position component <span class="math inline">\(x_k\)</span> is obtained by integrating acceleration twice (via velocity). As a result, the statistical behavior of position is highly sensitive to how acceleration is modeled. In many applications, position is the central quantity of interest: we care about predicting where the point will be, often more than how fast it will be moving.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A note on the input integral and its interpretation
</div>
</div>
<div class="callout-body-container callout-body">
<p>The term <span class="math inline">\(\mathbf{u}_k\)</span> collects the effect of acceleration over the sampling interval. The integral in <a href="#eq-eq7" class="quarto-xref">Equation&nbsp;7</a> can be understood in the most basic sense: as a Riemann integral of a time-varying input. To give this integral a concrete meaning, it is sufficient to assume that the acceleration process is locally piecewise constant. More precisely, we assume that <span class="math inline">\(a(t)\)</span> is constant over each subinterval of an arbitrary partition of the integration interval <span class="math inline">\((0,T)\)</span>. This assumption is made with respect to the integration variable and does not impose any restriction tied to the sampling interval <span class="math inline">\(T\)</span>.</p>
<p>At this level, <span class="math inline">\(T\)</span> plays no special role beyond defining the limits of integration. There is no implicit connection with sampling theory in the sense of Shannon, nor with any bandwidth limitation on <span class="math inline">\(a(t)\)</span>. The piecewise-constant assumption should therefore be interpreted as a minimal modeling device that allows the effect of acceleration over a finite time interval to be accumulated through integration.</p>
</div>
</div>
</section>
<section id="the-discrete-time-input-covariance-q_d" class="level2">
<h2 class="anchored" data-anchor-id="the-discrete-time-input-covariance-q_d">The discrete-time input covariance <span class="math inline">\(Q_d\)</span></h2>
<p>A specific stochastic model is now introduced: acceleration <span class="math inline">\(a(t)\)</span> is regarded as a wide-sense stationary stochastic process with zero mean, <span class="math inline">\(\mathbb{E}[a(t)]=0\)</span>, and autocorrelation function:</p>
<p><span id="eq-eq8"><span class="math display">\[
R_a(\tau) \;\triangleq\; \mathbb{E}\!\left[a(t)\,a(t+\tau)\right]
\tag{8}\]</span></span></p>
<p>In the constant-velocity kinematic model, a zero-mean acceleration describes random deviations around a nominal constant velocity, with no preferred direction of motion.</p>
<p>The covariance matrix of <span class="math inline">\(\mathbf{u}_k\)</span> is defined as</p>
<p><span id="eq-eq9"><span class="math display">\[
Q_d\;\triangleq\;\mathrm{Cov}(\mathbf{u}_k)
           \;=\;\mathbb{E}\!\left[\mathbf{u}_k\,\mathbf{u}_k^\top\right]
\tag{9}\]</span></span></p>
<p>where the last equality requires that <span class="math inline">\(\mathbb{E}[\mathbf{u}_k]=\mathbf{0}\)</span> (this follows from the linearity of both the expectation operator and the integral).</p>
<p>Substituting the expression for <span class="math inline">\(\mathbf{u}_k\)</span> in <a href="#eq-eq7" class="quarto-xref">Equation&nbsp;7</a> into <a href="#eq-eq9" class="quarto-xref">Equation&nbsp;9</a> yields:</p>
<p><span id="eq-eq10"><span class="math display">\[
Q_d = \int_0^T \!\!\int_0^T
e^{A(T-\tau)}\,B\;
\mathbb{E}\!\left[a(t_k+\tau)\,a(t_k+s)\right]\;
B^\top e^{A^\top(T-s)}\, d\tau\,ds.
\tag{10}\]</span></span></p>
<p>Under the stationarity assumption, the expectation depends only on <span class="math inline">\(\tau-s\)</span>, and we obtain:</p>
<p><span id="eq-eq11"><span class="math display">\[
Q_d = \int_0^T \!\!\int_0^T
e^{A(T-\tau)}\,B\;
R_a(\tau-s)\;
B^\top e^{A^\top(T-s)}\, d\tau\,ds.
\tag{11}\]</span></span></p>
<p>This expression makes the central point explicit: the discrete-time covariance <span class="math inline">\(Q_d\)</span> is determined by the autocorrelation structure of acceleration over the sampling interval.</p>
<p>For the one-dimensional constant-velocity kinematic model, with <span class="math inline">\(B\)</span> and <span class="math inline">\(e^{AT}\)</span> as in <a href="#eq-eq4" class="quarto-xref">Equation&nbsp;4</a> and <a href="#eq-eq6" class="quarto-xref">Equation&nbsp;6</a> respectively, we can write:</p>
<p><span id="eq-eq12"><span class="math display">\[
e^{A(T-\tau)}\,B = \begin{bmatrix} T-\tau\\ 1 \end{bmatrix}
\tag{12}\]</span></span></p>
<p>As a result, the discrete-time covariance matrix can be written explicitly as</p>
<p><span id="eq-eq13"><span class="math display">\[
Q_d = \int_0^T\!\!\int_0^T \begin{bmatrix} T-\tau\\ 1 \end{bmatrix}
R_a(\tau-s)
\begin{bmatrix} T-s &amp; 1 \end{bmatrix} \,d\tau\,ds
\tag{13}\]</span></span></p>
<p>Written component-wise, this expression highlights how each entry of <span class="math inline">\(Q_d\)</span> is obtained by weighting the autocorrelation function of acceleration with deterministic kernels:</p>
<p><span id="eq-eq14"><span class="math display">\[
Q_d =
\begin{bmatrix}
\displaystyle \int_0^T\!\!\int_0^T (T-\tau)(T-s)\,R_a(\tau-s)\,d\tau\,ds
&amp;
\displaystyle \int_0^T\!\!\int_0^T (T-\tau)\,R_a(\tau-s)\,d\tau\,ds
\\[0.6em]
\displaystyle \int_0^T\!\!\int_0^T (T-s)\,R_a(\tau-s)\,d\tau\,ds
&amp;
\displaystyle \int_0^T\!\!\int_0^T R_a(\tau-s)\,d\tau\,ds
\end{bmatrix}
\tag{14}\]</span></span></p>
<p>At this point, no assumption has yet been made on the specific form of <span class="math inline">\(R_a(\cdot)\)</span>. The structure of <span class="math inline">\(Q_d\)</span> is entirely determined by the kinematics; the autocorrelation function of acceleration determines its numerical values.</p>
</section>
<section id="white-noise-acceleration-as-a-limiting-model" class="level2">
<h2 class="anchored" data-anchor-id="white-noise-acceleration-as-a-limiting-model">White noise acceleration as a limiting model</h2>
<p>We now consider a specific, and widely used, stochastic model for acceleration: <em>white noise acceleration</em>. Formally, acceleration is modeled as a zero-mean stochastic process with autocorrelation</p>
<p><span id="eq-eq15"><span class="math display">\[
R_a(\tau) = q\,\delta(\tau)
\tag{15}\]</span></span></p>
<p>where <span class="math inline">\(\delta(\cdot)\)</span> denotes the Dirac delta and the noise strength <span class="math inline">\(q\)</span> is a constant. This expression should not be interpreted literally as a function: white noise does not exist as a time function in the usual sense. Rather, it is a mathematical idealization that captures the idea of rapidly varying, uncorrelated fluctuations. What matters for our purposes is that the autocorrelation is impulsive, and that all second-order properties of the process are encoded in the single parameter <span class="math inline">\(q\)</span>.</p>
<p>The parameter <span class="math inline">\(q\)</span> has a clear physical dimension. Acceleration has units of length over time squared, <span class="math inline">\([a] = \mathrm{L}/\mathrm{T}^2\)</span>, the Dirac delta has units of inverse time, and the autocorrelation has units <span class="math inline">\(\mathrm{L}^2/\mathrm{T}^4\)</span>. It follows that <span class="math inline">\([q] = \mathrm{L}^2/\mathrm{T}^3.\)</span> This dimensional analysis makes explicit that <span class="math inline">\(q\)</span> is the (constant) power spectral density (PSD) of the white noise acceleration.</p>
<p>Substituting <a href="#eq-eq15" class="quarto-xref">Equation&nbsp;15</a> into <a href="#eq-eq14" class="quarto-xref">Equation&nbsp;14</a>, each double integral defining <span class="math inline">\(Q_d\)</span> collapses to a single integral:</p>
<p><span id="eq-eq16"><span class="math display">\[
Q_d
=
q \int_0^T
\begin{bmatrix}
(T-\tau)^2 &amp; T-\tau\\
T-\tau &amp; 1
\end{bmatrix}
\,d\tau.
\tag{16}\]</span></span></p>
<p>Evaluating the integral yields the well-known result:</p>
<p><span id="eq-eq17"><span class="math display">\[
Q_d =
q\begin{bmatrix}
T^3/3 &amp; T^2/2 \\
T^2/2 &amp; T
\end{bmatrix}.
\tag{17}\]</span></span></p>
<p>This matrix summarizes, in discrete time, the cumulative effect of continuous-time white acceleration over one sampling interval.</p>
<p>It is worth stressing that the discrete-time covariance <span class="math inline">\(Q_d\)</span> depends not only on the noise PSD, but also explicitly on the sampling interval <span class="math inline">\(T\)</span>. Changing <span class="math inline">\(T\)</span> without recomputing <span class="math inline">\(Q_d\)</span> therefore amounts to changing the underlying model, not merely its numerical implementation.</p>
<section id="on-simulation-and-sample-paths" class="level3">
<h3 class="anchored" data-anchor-id="on-simulation-and-sample-paths">On simulation and sample paths</h3>
<p>Although white noise acceleration is a convenient analytical model, it cannot be simulated directly as a time function. To generate consistent sample paths, one must work with a time-integrated process. In practice, this amounts to simulating independent increments whose variance scales with the time step, in the same spirit as the construction of the Wiener process. These increments are assumed to be Gaussian, and position and velocity trajectories are obtained by integrating them, rather than by sampling acceleration itself. Strictly speaking, the Gaussian assumption is not essential, but it provides a convenient and widely used framework; more generally, a normal joint distribution for position and velocity may arise as a limiting approximation via the central limit theorem.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Generating correlated increments via a linear transformation
</div>
</div>
<div class="callout-body-container callout-body">
<p>In the discrete-time model <a href="#eq-eq5" class="quarto-xref">Equation&nbsp;5</a>, the random vector <span class="math inline">\(\mathbf{u}_k\)</span> represents the integrated effect of acceleration over one sampling interval. It is a two-dimensional Gaussian vector, with zero mean and covariance <span class="math inline">\(Q_d\)</span>.</p>
<p>A convenient way to generate <span class="math inline">\(\mathbf{u}_k\)</span> is to start from a vector of independent standard Gaussian variables, <span class="math inline">\(\mathbf{z}_k \sim \mathcal{N}(\mathbf{0}, I)\)</span>, and apply the linear transformation</p>
<p><span id="eq-eq18"><span class="math display">\[
\mathbf{u}_k = L\,\mathbf{z}_k,
\qquad
Q_d = L\,L^\top.
\tag{18}\]</span></span></p>
<p>This construction makes the role of the transformation explicit: the matrix <span class="math inline">\(L\)</span> introduces both the correct scaling and the correlation structure between the components of <span class="math inline">\(\mathbf{u}_k\)</span>. In practice, <span class="math inline">\(L\)</span> can be obtained via a Cholesky factorization of <span class="math inline">\(Q_d\)</span>, but the key idea is the linear mapping from independent to correlated random variables. In the example discussed in this post, the matrix <span class="math inline">\(L\)</span> can be written as follows: <span id="eq-eq19"><span class="math display">\[
L = \sqrt{q\,T}
\begin{bmatrix} \dfrac{T}{2\sqrt{3}} &amp; \dfrac{T}{2} \\ 0 &amp; 1 \end{bmatrix}
\tag{19}\]</span></span></p>
</div>
</div>
</section>
<section id="a-conceptual-remark-on-dimensions-and-modeling" class="level3">
<h3 class="anchored" data-anchor-id="a-conceptual-remark-on-dimensions-and-modeling">A conceptual remark on dimensions and modeling</h3>
<p>It is worth pausing for a moment to reflect on what has just happened.</p>
<p>We started in continuous time with a system driven by an acceleration input, whose physical dimension is <span class="math inline">\([\mathrm{L}\,\mathrm{T}^{-2}]\)</span>. After discretization, we end up with a two-dimensional input (<span class="math inline">\(\mathbf{u}\_k\)</span>) whose components have dimensions <span class="math inline">\([\mathrm{L}]\)</span> and <span class="math inline">\([\mathrm{L}\,\mathrm{T}^{-1}]\)</span>, corresponding to increments of position and velocity.</p>
<p>This is not a contradiction, but a direct consequence of integration over time. In the discrete-time model, the input no longer represents an instantaneous physical quantity, but the cumulative effect of acceleration over a finite interval.</p>
<p>What is particularly noteworthy is that these two components are correlated. They are statistically ‚Äúglued together‚Äù through the covariance matrix <span class="math inline">\(Q_d\)</span>, which encodes how uncertainty injected through acceleration propagates jointly into position and velocity during a single time step.</p>
<p>In this sense, discretization transforms a scalar continuous-time acceleration input into a vector-valued discrete-time input with coupled components and nontrivial physical units. Understanding this transformation is essential to avoid misinterpreting the role of process noise in discrete-time motion models.</p>
</section>
<section id="a-final-remark-on-the-role-of-the-sampling-interval" class="level3">
<h3 class="anchored" data-anchor-id="a-final-remark-on-the-role-of-the-sampling-interval">A final remark on the role of the sampling interval</h3>
<p>A final comment concerns the role of the sampling interval <span class="math inline">\(T\)</span>. In the present context, <span class="math inline">\(T\)</span> should be interpreted primarily as an integration step. The discrete-time model is exact at the sampling times, and the construction of the random input <span class="math inline">\(\mathbf{u}_k\)</span> guarantees that the resulting position and velocity sample paths have the correct second-order statistics, regardless of the specific value of <span class="math inline">\(T\)</span>, within broad limits dictated by the validity of the underlying continuous-time model.</p>
<p>This is different from what happens in a Kalman filtering or tracking context, where <span class="math inline">\(T\)</span> determines how long the system must evolve ‚Äúopen-loop‚Äù based on the motion model alone, between successive measurements. Here, no estimation is being performed, and no measurements are involved.</p>
<p>As a result, <span class="math inline">\(T\)</span> does not control prediction horizon or estimator performance, but simply sets the time scale over which the continuous-time stochastic input is integrated. As long as the discrete-time covariance <span class="math inline">\(Q_d\)</span> is constructed consistently, changing <span class="math inline">\(T\)</span> does not introduce integration errors: it only changes how uncertainty accumulates over time.</p>
<p>It is also important to stress what this construction does ‚Äî and does not ‚Äî provide. Nothing can be said about what happens between sampling times. The continuous-time trajectory is not reconstructed, nor is it assumed to be known in any meaningful sense. What is guaranteed, instead, is that the stochastic process is characterized exactly at the sampling times. Moreover, in the Gaussian case considered here, the statistical behavior of position and velocity at discrete times is fully described by their mean and covariance.</p>
<p>In this sense, the discrete-time model provides a complete and exact statistical description of the motion at sampling times, even though the underlying continuous-time path remains unknown. Strictly speaking, <span class="math inline">\(Q_d\)</span> should not be thought of as a generic hyperparameter to be tuned (e.g., in a Kalman-based tracker), but as a quantity implied by the chosen stochastic model for acceleration ‚Äî even though, in practice, it is often used as a tool for absorbing the effects of unmodeled dynamics.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Two difference equations, one stochastic model?
</div>
</div>
<div class="callout-body-container callout-body">
<p>A natural question arises at this point; a related discussion can be found in one <a href="https://amsabatini.netlify.app/posts/numerical_simulation/">previous post</a> of mine. If white noise acceleration is written in continuous time as a stochastic differential equation, we have:</p>
<p><span id="eq-eq20"><span class="math display">\[
\left\{
\begin{align}
dx(t)&amp;=v(t)\,dt\\
dv(t)&amp;=\sqrt{q}\,dW(t)
\end{align}
\right.
\tag{20}\]</span></span></p>
<p>then the Euler‚ÄìMaruyama (EM) scheme on a fine grid with step <span class="math inline">\(h\)</span> reads</p>
<p><span id="eq-eq21"><span class="math display">\[
\left\{
\begin{align}
x_{n+1}&amp;=x_n+h\,v_n\\
v_{n+1}&amp;=v_n+\sqrt{q}\,\sqrt{h}\,\xi_n\qquad \xi_n \sim \mathcal N(0,1)
\end{align}
\right.
\tag{21}\]</span></span></p>
<p>At first sight, this update looks structurally different from that in <a href="#eq-eq5" class="quarto-xref">Equation&nbsp;5</a>: the noise appears explicitly only in the velocity equation, while in the exact discrete-time model randomness enters both position and velocity through <span class="math inline">\(\mathbf{u}_k\)</span>.</p>
<p>The apparent mismatch disappears once one recognizes that the two constructions address different objects.</p>
<ul>
<li>EM is a pathwise approximation method: it builds an approximate continuous-time trajectory on a refined grid. Under standard regularity conditions (satisfied here, since the model is linear), EM converges with strong order <span class="math inline">\(1/2\)</span> (mean-square or pathwise accuracy) and with weak order <span class="math inline">\(1\)</span> (accuracy in the distribution of smooth functionals).</li>
<li>The exact discrete-time model does not approximate trajectories between samples. It constructs directly the correct joint distribution of <span class="math inline">\((x(t_k),v(t_k))\)</span>, by integrating the stochastic input over a finite interval of length <span class="math inline">\(T\)</span>.</li>
</ul>
<p>As a consequence, the two difference equations are not expected to coincide in form. What can be reconciled is their statistical output at fixed times: if EM is run with a sufficiently small step <span class="math inline">\(h\)</span> and the resulting trajectory is inspected only at the coarse sampling times <span class="math inline">\(t_k=kT\)</span> (with <span class="math inline">\(T\)</span> an integer multiple of <span class="math inline">\(h\)</span>), then the distribution of the EM state <span class="math inline">\((x_k,v_k)\)</span> converges (as <span class="math inline">\(h\to0\)</span>) to the same distribution implied by the exact discrete-time covariance <span class="math inline">\(Q_d\)</span>. The covariance <span class="math inline">\(P_k\)</span> of the EM state at the sampling times can be calculated by solving:</p>
<p><span id="eq-eq22"><span class="math display">\[
P_{k+1}=e^{AT}P_k(e^{AT})^\top+Q_d
\tag{22}\]</span></span></p>
<p>In this sense, EM converges to the correct model in distribution, even though its local update equation looks different.</p>
</div>
</div>
</section>
</section>
<section id="concluding-remarks" class="level2">
<h2 class="anchored" data-anchor-id="concluding-remarks">Concluding remarks</h2>
<p>The goal of this post was not to provide an exhaustive discussion of stochastic acceleration models, nor to explore the interpretation of white noise as the limit of rapidly fluctuating correlated processes.</p>
<p>Rather, the focus was on understanding how a simple kinematic model, when driven by a stochastic input, can be consistently carried from continuous time to discrete time, and how the statistical properties of that input propagate into the discrete-time state increments.</p>
<p>Within this framework, white acceleration was introduced as a convenient and widely used specialization that leads to a closed-form expression for the discrete-time covariance <span class="math inline">\(Q_d\)</span>. It should be regarded as one modeling choice among others, not as a physical description of acceleration itself.</p>
<p>What matters, ultimately, is not the specific choice of model, but the clarity with which its assumptions are stated and their consequences understood. Even for the simplest possible motion problem, careful modeling at this level can make a substantial difference.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/amsabatini\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="angelosabatini/blog.comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>